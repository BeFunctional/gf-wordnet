#!/usr/bin/env python

import pygtk
pygtk.require('2.0')
import gtk
import pgf
import shutil
import subprocess
import os.path
import sys

class Editor:
    modules = [
         ("English",   "WordNetEng.gf", "ParseEng.gf")
		,("Swedish",   "WordNetSwe.gf", "ParseSwe.gf")
        ,("Bulgarian", "WordNetBul.gf", "ParseBul.gf")
        ]

    def delete_event(self, widget, event, data=None):
        return False

    def destroy(self, widget, data=None):
        gtk.main_quit()

    def reset_editor(self):
        self.entry.set_text("");
        self.textbuffer_abstr.set_text("");
        self.textbuffer_abstr.set_modified(False)
        self.textbuffer_exmpl.set_text("");
        self.textbuffer_exmpl.set_modified(False)
        self.textbuffer_gloss.set_text("");
        self.textbuffer_gloss.set_modified(False)
        for (lang,wordnet,parse,textbuffer) in self.modules:
			textbuffer.set_text("")
			textbuffer.set_modified(False)

    def search(self, widget, data=None):
        self.notifyNeedsSave()

        query = self.entry.get_text()
        self.reset_editor()
        self.treestore.clear()
        if query in self.lemma2funs:
			self.defs = {}
			for fun in self.lemma2funs[query]:
				self.defs[fun] = {}
				values = [fun]
				for (lang, wordnet, parse, textbuffer) in self.modules:
					values.append("")
				it = self.treestore.append(None,values)
				for syn_fun in self.fun2synset.get(fun,[]):
					if fun == syn_fun:
						continue
					self.defs[syn_fun] = {}
					values = [syn_fun]
					for lang in self.modules:
						values.append("")
					self.treestore.append(it,values)
			self.loadExamples()

			self.loadAbstract()
			self.loadConcrete()

			self.buildMiniGrammar()

        self.saveButton.set_sensitive(False)
        self.deleteButton.set_sensitive(False)

    def cursor_changed(self, treeview, data=None):
		(model, piter) = treeview.get_selection().get_selected()
		if piter == None:
			return

		self.notifyNeedsSave()

		self.selectFunction(self.treestore.get_value(piter,0))

    def save_event(self, widget, data=None):
        self.saveAbstract()
        self.saveConcrete()

        if self.fun != self.new_fun:
			self.updateMapping()

			self.defs[self.new_fun] = self.defs[self.fun]
			del self.defs[self.fun]

			for lst in self.fun2lists[self.fun]:
				lst.remove(self.fun)
				lst.append(self.new_fun)
			self.fun2lists[self.new_fun] = self.fun2lists[self.fun]
			del self.fun2lists[self.fun]

			def update_tree_rows(treeiter):
				while treeiter is not None:
					if self.treestore[treeiter][0] == self.fun:
						self.treestore[treeiter][0] = self.new_fun

					if self.treestore.iter_has_child(treeiter):
						childiter = self.treestore.iter_children(treeiter)
						update_tree_rows(childiter)
					treeiter = self.treestore.iter_next(treeiter)

			update_tree_rows(self.treestore.get_iter_first())
			
			self.fun = self.new_fun
			del self.new_fun

        if self.detectNewFunctions():
			self.loadAbstract()
			self.loadConcrete()

        self.buildMiniGrammar()

        self.saveButton.set_sensitive(False)

    def delete_function_event(self, widget, data=None):
		self.deleteAbstract()
		self.deleteConcrete()
		self.deleteMapping()

		del self.defs[self.fun]
		for lst in self.fun2lists[self.fun]:
			lst.remove(self.fun)

		self.reset_editor()
		def remove_tree_rows(treeiter):
			while treeiter is not None:
				if self.treestore[treeiter][0] == self.fun:
					self.treestore.remove(treeiter)

				if self.treestore.iter_has_child(treeiter):
					childiter = self.treestore.iter_children(treeiter)
					remove_tree_rows(childiter)
				treeiter = self.treestore.iter_next(treeiter)

		remove_tree_rows(self.treestore.get_iter_first())
		
		self.deleteButton.set_sensitive(False)

    def changed_event(self, widget, data=None):
		self.saveButton.set_sensitive(True)

    def needsSave(self):
		if (self.textbuffer_abstr.get_modified() or self.textbuffer_gloss.get_modified()):
			return True

		for (lang, wordnet, parse, textbuffer) in self.modules:
			if (textbuffer.get_modified()):
				return True

		return False

    def notifyNeedsSave(self):
		if self.needsSave():
			dlg = gtk.MessageDialog(self.window, type=gtk.MESSAGE_QUESTION, buttons=gtk.BUTTONS_YES_NO)
			dlg.set_markup("Do you want to save the changes?")

			response = dlg.run()
			dlg.destroy()

			if response == gtk.RESPONSE_YES:
				self.save_event(None, None)

    def setupTreeColumn(self, lang, i):
		tvcolumn = gtk.TreeViewColumn(lang)

		# add tvcolumns to treeview
		self.treeview.append_column(tvcolumn)

		cell = gtk.CellRendererText()

		# add the cell to the tvcolumn and allow it to expand
		tvcolumn.pack_start(cell, True)

		# set the cell "text" attribute to column 0 - retrieve text
		# from that column in treestore
		tvcolumn.add_attribute(cell, 'text', i)

		# Allow sorting on the column
		tvcolumn.set_sort_column_id(i)
		
		return tvcolumn

    def setupTextView(self,vbox,title):
		label = gtk.Label(title)
		label.set_alignment(0,0)

		textbuffer = gtk.TextBuffer()
		textbuffer.connect("changed", self.changed_event)

		textview = gtk.TextView()
		textview.set_buffer(textbuffer);
		
		viewport = gtk.Viewport()
		viewport.add(textview)

		vbox.pack_start(label,False)
		vbox.pack_start(viewport,True)
		
		return textbuffer
		
    def next_tree(self, widget, data=None):
		self.loadNextExample()

    def __init__(self):
		# load the grammar
        (self.lemma2funs,self.fun2lists) = self.loadGrammarCache()

        self.fun2synset = self.loadSynsets()

        self.fun = None

        # create a new window
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.resize(1000,700)
    
        # When the window is given the "delete_event" signal (this is given
        # by the window manager, usually by the "close" option, or on the
        # titlebar), we ask it to call the delete_event () function
        # as defined above. The data passed to the callback
        # function is NULL and is ignored in the callback function.
        self.window.connect("delete_event", self.delete_event)
    
        # Here we connect the "destroy" event to a signal handler.  
        # This event occurs when we call gtk_widget_destroy() on the window,
        # or if we return FALSE in the "delete_event" callback.
        self.window.connect("destroy", self.destroy)
    
        # Sets the border width of the window.
        self.window.set_border_width(10)

        accel_group = gtk.AccelGroup()
        self.window.add_accel_group(accel_group)

        self.entry = gtk.Entry()
        self.entry.connect("activate", self.search, None)

        search_button = gtk.Button("Search")
        search_button.connect("clicked", self.search, None)

        hbox1 = gtk.HBox()
        hbox1.pack_start(self.entry,True)
        hbox1.pack_end(search_button,False)

        self.treestore = gtk.TreeStore(str,str,str,str)
        self.treeview = gtk.TreeView(self.treestore)
        self.treeview.connect('cursor-changed', self.cursor_changed, None)

        i = 0

        self.setupTreeColumn("Abstract", i)
        i = i+1

        for (lang,wordnet,parse) in self.modules:
			self.setupTreeColumn(lang, i)
			i = i+1

        scrolledwindow = gtk.ScrolledWindow()
        scrolledwindow.add(self.treeview)

        toolbar = gtk.Toolbar()
        self.saveButton   = toolbar.insert_stock(gtk.STOCK_SAVE,
                               "Saves the changes",
                               "Private",
                               self.save_event,
                               None, 0)
        self.deleteButton = toolbar.insert_stock(gtk.STOCK_DELETE,
                               "Deletes the current function",
                               "Private",
                               self.delete_function_event,
                               None, 1)

        self.saveButton.set_sensitive(False)
        self.saveButton.add_accelerator("activate", accel_group,
                                        ord('S'), gtk.gdk.CONTROL_MASK, gtk.ACCEL_VISIBLE)

        self.deleteButton.set_sensitive(False)

        vbox2 = gtk.VBox()
        vbox2.pack_start(toolbar,False)
        self.textbuffer_gloss = self.setupTextView(vbox2, "Gloss")
        
        self.textbuffer_exmpl = gtk.TextBuffer()
        self.textbuffer_exmpl.connect("changed", self.changed_event)

        textview_exmpl = gtk.TextView()
        textview_exmpl.set_buffer(self.textbuffer_exmpl);

        viewport = gtk.Viewport()
        viewport.add(textview_exmpl)

        hbox = gtk.HBox()
        example_button = gtk.Button("Example")
        example_button.connect("clicked", self.next_tree, None)
        example_button.add_accelerator("activate", accel_group,
                                       ord('E'), gtk.gdk.CONTROL_MASK, gtk.ACCEL_VISIBLE)
        hbox.pack_start(example_button,False)

        vbox2.pack_start(hbox,False)
        vbox2.pack_start(viewport,True)

        self.textbuffer_abstr = self.setupTextView(vbox2, "Abstract")

        for i in xrange(len(self.modules)):
			(lang,wordnet,parse) = self.modules[i]
			textbuffer = self.setupTextView(vbox2, lang)
			self.modules[i] = (lang,wordnet,parse,textbuffer)

        vbox1 = gtk.VBox()
        vbox1.pack_start(hbox1, False)
        vbox1.pack_start(scrolledwindow, True)

        hpaned = gtk.HPaned()
        hpaned.add1(vbox1)
        hpaned.add2(vbox2)
        hpaned.set_position(350)

        # This packs the button into the window (a GTK container).
        self.window.add(hpaned)

        # and the window
        self.window.show_all()

    def loadSynsets(self):
		f = open("WordNet.gf", "r")
		fun2synset = {}
		synsets    = {}
		for line in f:
			ws = line.split()
			if len(ws) > 2 and ws[0] == "fun":
				fun = ws[1]
				parts = line.split('--')
				if len(parts) == 2:
					[abstr,comment] = parts
					abstr = abstr.strip()
					[synset_id,descr] = comment.split('\t')
					if synset_id in synsets:
						synset = synsets[synset_id]
					else:
						synset = []
						synsets[synset_id] = synset
					fun2synset[fun] = synset
					synset.append(fun)
		f.close()
		return fun2synset

    def loadAbstract(self):
		file_name = "WordNet.gf"
		f = open(file_name, "r")
		abstr  = None
		synset = None
		descr  = None
		for line in f:
			ws = line.split()
			if len(ws) > 2 and ws[0] == "fun" and ws[1] in self.defs:
				parts = line.split('--')
				if len(parts) == 2:
					[abstr,comment] = line.split('--')
					abstr = abstr.strip()
					[synset,descr] = comment.split('\t')
					synset = synset.strip()
					descr  = descr.strip()

					gloss    = ""
					examples = []
					i        = 0
					start    = i
					while i < len(descr):
						if descr[i] == ';':
							if descr[start] == '"':
								if descr[i-1] == '"':
									example = descr[start+1:i-1]
								else:
									example = descr[start:i]
								examples.append(example)
							else:
								if gloss == "":
									gloss = descr[start:i]
								else:
									gloss = gloss + "; " + descr[start:i]
							i = i+1
							while descr[i].isspace():
								i = i+1
							start = i
						else:
							if descr[i] == '"':
								while i < len(descr) and descr[i] != '"':
									i = i+1
							i = i+1
					if start < len(descr) and descr[start] == '"':
						if descr[i-1] == '"':
							example = descr[start+1:i-1]
						else:
							example = descr[start:i]
						examples.append(example)
					else:
						gloss = gloss + "; " + descr[start:i]
				else:
					abstr    = line.strip()
					synset   = None
					gloss    = ""
					examples = []
				self.defs[ws[1]][file_name] = (abstr,synset,descr,examples)
		f.close()

    def saveAbstract(self):
		self.new_fun = self.fun

		if not (self.textbuffer_abstr.get_modified() or self.textbuffer_gloss.get_modified()):
			return

		abstr = self.textbuffer_abstr.get_text(*self.textbuffer_abstr.get_bounds())
		gloss = self.textbuffer_gloss.get_text(*self.textbuffer_gloss.get_bounds())

		ws = abstr.split()
		if len(ws) > 2 and ws[0] == "fun":
			self.new_fun = ws[1]

		file_name = "WordNet.gf"
		inp = open(file_name, "r")
		out = open("__temp__", "w")
		for line in inp:
			ws = line.split()
			if len(ws) > 2 and ws[0] == "fun" and ws[1] == self.fun:
				if self.synset == None:
					line = abstr
				else:
					line = abstr.ljust(35)+"-- "+self.synset+"\t"+gloss+"\n"
			out.write(line)
		inp.close()
		out.close()
		shutil.move("__temp__", "WordNet.gf")

		self.textbuffer_abstr.set_modified(False)
		self.textbuffer_gloss.set_modified(False)
		
		abs_def = self.defs[self.fun][file_name]
		self.defs[self.fun][file_name] = (abstr,abs_def[1],gloss,abs_def[3])

    def deleteAbstract(self):
		inp = open("WordNet.gf", "r")
		out = open("__temp__", "w")
		for line in inp:
			ws = line.split()
			if len(ws) > 2 and ws[0] == "fun" and ws[1] == self.fun:
				pass
			else:
				out.write(line)
		inp.close()
		out.close()
		shutil.move("__temp__", "WordNet.gf")

    def loadConcrete(self):
		for (lang,wordnet,parse,text_buffer) in self.modules:
			inp = open(wordnet, "r")
			while True:
				line = inp.readline()
				if line == '':
					break

				ws   = line.split()
				if len(ws) > 2 and ws[0] == "lin" and ws[1] in self.defs:
					count = 0
					body  = ""
					while line != '':
						body = body + line
						for c in line:
							if c == '{' or c == '(' or c == '[':
								count = count + 1
							if c == '}' or c == ')' or c == ']':
								count = count - 1
						if count == 0:
							break
						line = inp.readline()
					self.defs[ws[1]][wordnet] = body.strip()
			inp.close()

    def saveConcrete(self):
		for (lang,wordnet,parse,textbuffer) in self.modules:
			if not textbuffer.get_modified():
				continue

			concr = textbuffer.get_text(*textbuffer.get_bounds())

			inp = open(wordnet, "r")
			out = open("__temp__", "w")
			for line in inp:
				ws = line.split()
				if len(ws) > 2 and ws[0] == "lin" and ws[1] == self.fun:
					line = concr+"\n"
				out.write(line)
			inp.close()
			out.close()
			shutil.move("__temp__", wordnet)

			textbuffer.set_modified(False)

			self.defs[self.fun][wordnet] = concr

    def deleteConcrete(self):
		for (lang,wordnet,parse,textbuffer) in self.modules:
			inp = open(wordnet, "r")
			out = open("__temp__", "w")
			for line in inp:
				ws = line.split()
				if len(ws) > 2 and ws[0] == "lin" and ws[1] == self.fun:
					pass
				else:
					out.write(line)
			inp.close()
			out.close()
			shutil.move("__temp__", wordnet)

    def updateMapping(self):
		inp = open("mapping.txt", "r")
		out = open("__temp__", "w")
		for line in inp:
			ws = line.split()
			if len(ws) > 1 and ws[1] == self.fun:
				line = ws[0] + "\t" + self.new_fun + "\n"
			out.write(line)
		inp.close()
		out.close()
		shutil.move("__temp__", "mapping.txt")

    def deleteMapping(self):
		inp = open("mapping.txt", "r")
		out = open("__temp__", "w")
		for line in inp:
			ws = line.split()
			if len(ws) > 1 and ws[1] == self.fun:
				pass
			else:
				out.write(line)
		inp.close()
		out.close()
		shutil.move("__temp__", "mapping.txt")

    def loadExampleLexicon(self,e):
		app = e.unpack()
		if type(app) == tuple:
			fun = app[0]
			if fun in self.fun2synset:
				self.defs[fun] = {}
				values = [fun]
				for (lang,wordnet,parse,textbuffer) in self.modules:
					values.append("")
				it = self.treestore.append(None,values)

				for syn_fun in self.fun2synset.get(fun,[]):
					if fun == syn_fun:
						continue
					self.defs[syn_fun] = {}
					values = [syn_fun]
					for lang in self.modules:
						values.append("")
					self.treestore.append(it,values)
			else:
				for e in app[1]:
					self.loadExampleLexicon(e)

    def loadExamples(self):
		def addLexicon(e):
			app = e.unpack()
			if type(app) == tuple:
				if len(app[1]) == 0:
					self.defs.setdefault(app[0], {})
				else:
					for e in app[1]:
						addLexicon(e)

		defs_copy = self.defs.copy()

		inp = open("examples.txt", "r")
		while True:
			l0 = inp.readline()
			l1 = inp.readline()
			l2 = inp.readline()
			l3 = inp.readline()
			l4 = inp.readline()
			l5 = inp.readline()

			if l0 == '':
				break

			ws = l4[5:-1].split()
			funs = ws[1:int(ws[0])+1]
			for fun in funs:
				if fun in defs_copy:
					addLexicon(pgf.readExpr(l0[5:-1]))

					lines = self.defs[fun].setdefault("examples.txt",[])
					lines.append(l0)
					lines.append(l1)
					lines.append(l2)
					lines.append(l3)
					lines.append(l4)
					lines.append(l5)
		inp.close()

		for fun in defs_copy:
			examples = self.defs[fun].get("examples.txt",[])
			self.defs[fun]["examples.txt"] = "".join(examples)

    def saveExamples(self, all_lines):
		inp = open("examples.txt", "r")
		out = open("__temp__", "w")

		l0 = inp.readline()
		while True:
			l1 = inp.readline()
			if l1 == '':
				break

			for xlines in all_lines:
				if xlines[1] == l1:
					l2 = inp.readline()
					l3 = inp.readline()
					l4 = inp.readline()
					l5 = inp.readline()

					for line in xlines:
						out.write(line)

					l0 = inp.readline()
					break
			else:
				out.write(l0)
				l0 = l1
		out.write(l0)

		out.close()
		inp.close()
		shutil.move("__temp__", "examples.txt")

    def updateExamples(self):
		lines     = []
		all_lines = []

		itr = self.textbuffer_exmpl.get_start_iter()
		while True:
			start = itr.copy()
			if not itr.forward_line():
				break
			line0 = self.textbuffer_exmpl.get_text(start,itr)
			if line0.startswith("abs*") or line0.startswith("abs:"):
				xlines = []

				xlines.append(line0)

				e = pgf.readExpr(line0[4:])

				start = itr.copy(); itr.forward_line()
				line1 = self.textbuffer_exmpl.get_text(start,itr)
				xlines.append(line1)

				start = itr.copy(); itr.forward_line()
				line2 = self.textbuffer_exmpl.get_text(start,itr)
				xlines.append(line2)

				start = itr.copy(); itr.forward_line()
				line3 = self.textbuffer_exmpl.get_text(start,itr)
				xlines.append(line3)
					
				start = itr.copy(); itr.forward_line()
				line4 = self.textbuffer_exmpl.get_text(start,itr)
				xlines.append(line4)

				start = itr.copy(); itr.forward_line()
				line5 = self.textbuffer_exmpl.get_text(start,itr)
				xlines.append(line5)

				all_lines.append(xlines)

				lines.extend(xlines)
				l = len(lines)

				lin   = self.gr.languages["ParseEng"].linearize(e)
				if lin.lower() != line1[5:-1].lower():
					lines.append("eng: "+lin+"\n")

				lin   = self.gr.languages["ParseSwe"].linearize(e)
				if lin.lower() != line2[5:-1].lower():
					lines.append("swe: "+lin+"\n")

				lin   = self.gr.languages["ParseBul"].linearize(e)
				if lin.lower() != line3[5:-1].lower():
					lines.append("bul: "+lin+"\n")
					
				if l != len(lines):
					lines.append("\n")

		if self.textbuffer_exmpl.get_modified():
			self.saveExamples(all_lines)

		examples = "".join(lines)
		self.defs[self.fun]["examples.txt"] = examples
		
		self.textbuffer_exmpl.set_text(examples)
		self.textbuffer_exmpl.set_modified(False)

    def loadNextExample(self):
		i     = -1
		lines = []
		inp = open("examples.txt", "r")
		for line in inp:
			if i < 0 and line.startswith("abs* Phr"):
				lines.append(line)
				i = 5
			elif i >= 0:
				lines.append(line)
				i = i - 1
				if i == 1:
					ws = line[5:-1].split()
					target_funs = ws[1:int(ws[0])+1]
				if i == 0:
					break
		inp.close()

		e = pgf.readExpr(lines[0][5:])
		self.treestore.clear()
		self.defs = {}
		self.loadExampleLexicon(e)

		self.loadExamples()
		for fun in target_funs:
			self.defs[fun]["examples.txt"] = "".join(lines)

		self.loadAbstract()
		self.loadConcrete()

		self.selectFunction(target_funs[0])

		self.buildMiniGrammar()
		
    def detectNewFunctions(self):
		def addLexicon(e):
			app = e.unpack()
			if type(app) == tuple:
				if len(app[1]) == 0:
					fun = app[0]
					if fun not in self.defs:
						self.defs[fun] = {}
						return True
				else:
					detected = False
					for e in app[1]:
						detected = detected or addLexicon(e)
					return detected
			else:
				return False

		detected = False
		itr = self.textbuffer_exmpl.get_start_iter()
		while True:
			start = itr.copy()
			if not itr.forward_line():
				break
			line = self.textbuffer_exmpl.get_text(start,itr)
			if line.startswith("abs*") or line.startswith("abs:"):
				e = pgf.readExpr(line[4:])
				detected = detected or addLexicon(e)
		return detected

    def selectFunction(self,fun):
		self.fun = fun
		fun_defs = self.defs[self.fun]
		(abstr,self.synset,gloss,examples) = fun_defs["WordNet.gf"]

		self.textbuffer_abstr.set_text(abstr)
		self.textbuffer_abstr.set_modified(False)
		self.textbuffer_gloss.set_text(gloss)
		self.textbuffer_gloss.set_modified(False)

		self.textbuffer_exmpl.set_text(fun_defs["examples.txt"])
		self.textbuffer_exmpl.set_modified(False)

		for (lang, wordnet, parse, textbuffer) in self.modules:
			textbuffer.set_text(fun_defs[wordnet])
			textbuffer.set_modified(False)

		self.saveButton.set_sensitive(False)
		self.deleteButton.set_sensitive(True)

    def loadGrammarCache(self):
		recompile = False
		if os.path.isfile("Parse.pgf"):
			source_files = []
			file_names = ["WordNet.gf", "Parse.gf"]
			for (lang,wordnet,parse) in self.modules:
				file_names.append(wordnet)
				file_names.append(parse)
			for file_name in file_names:
				if os.path.getmtime(file_name) >= os.path.getmtime("Parse.pgf"):
					recompile = True
					break
		else:
			recompile = True

		if recompile:
			cmd = ["gf", "--make"]
			for (lang,wordnet,parse) in self.modules:
				cmd.append(parse)
			subprocess.call(cmd)

		sys.stdout.write("Reading Parse.pgf... ")
		sys.stdout.flush()
		gr = pgf.readPGF("Parse.pgf")
		lemma2funs = {}
		fun2lists  = {}
		for lang in gr.languages:
			for (lemma,ans) in gr.languages[lang].fullFormLexicon():
				for (fun,an,prob) in ans:
					lst = lemma2funs.setdefault(lemma,[])
					if not fun in lst:
						lst.append(fun)
						lists = fun2lists.setdefault(fun,[])
						lists.append(lst)
		sys.stdout.write("\n")
		return (lemma2funs,fun2lists)

    def buildMiniGrammar(self):
		inp = open("Parse.gf", "r")
		out = open("lib/src/abstract/Parse.gf", "w")
		while True:
			l = inp.readline()
			if l == '':
				break
			if l == "  WordNet,\n":
				continue
			if l == "-- INJECT\n":
				for fun in self.defs:
					if "WordNet.gf" in self.defs[fun]:
						out.write(self.defs[fun]["WordNet.gf"][0]+"\n")
			else:
				out.write(l)
		out.close()
		inp.close()

		cmd = ["gf", "--make", "--output-dir=lib/src"]
		for (lang,wordnet,parse,textbuffer) in self.modules:
			file_name = "lib/src/"+lang.lower()+"/"+parse
			cmd.append(file_name)

			inp = open(parse, "r")
			out = open(file_name, "w")
			skip = "  "+wordnet[:-3]+",\n"
			while True:
				l = inp.readline()
				if l == '':
					break
				if l == skip:
					continue
				if l == "-- INJECT\n":
					for fun in self.defs:
						if wordnet in self.defs[fun]:
							out.write(self.defs[fun][wordnet]+"\n")
				else:
					out.write(l)
			out.close()
			inp.close()

		process = subprocess.Popen(cmd)
		
		def wait():
			if process.poll() != None:
				sys.stdout.write("Reading lib/src/Parse.pgf... ")
				sys.stdout.flush()
				self.gr = pgf.readPGF("lib/src/Parse.pgf")
				sys.stdout.write("\n")
				self.updateLinearizations()
				
				if self.fun != None:
					self.updateExamples()
				return

			gtk.timeout_add(500, wait)

		wait()
		
    def updateLinearizations(self):
		langs = self.gr.languages

		def update_tree_rows(treeiter):
			while treeiter is not None:
				i = 0

				e = pgf.Expr(self.treestore[treeiter][0],[])
				i = i+1

				for (lang, wordnet, parse, textbuffer) in self.modules:
					self.treestore[treeiter][i] = langs[parse[:-3]].linearize(e)
					i = i+1

				if self.treestore.iter_has_child(treeiter):
					childiter = self.treestore.iter_children(treeiter)
					update_tree_rows(childiter)
				treeiter = self.treestore.iter_next(treeiter)

		update_tree_rows(self.treestore.get_iter_first())

    def main(self):
		gtk.threads_enter()
		gtk.main()
		gtk.threads_leave()

# If the program is run directly or passed as an argument to the python
# interpreter then create a HelloWorld instance and show it
if __name__ == "__main__":
    editor = Editor()
    editor.main()
