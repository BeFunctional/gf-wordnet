#!/usr/bin/env python

import pygtk
pygtk.require('2.0')
import gtk
import webkit
import pgf
import shutil
import subprocess
import os.path
import sys

WHITESPACE = ("\r", "\n", "\t", " ")

class UndoableInsert(object):
    """something that has been inserted into our textbuffer"""
    def __init__(self, text_iter, text, length):
        self.offset = text_iter.get_offset()
        self.text = text
        self.length = length
        if self.length > 1:
            self.mergeable = False
        else:
            self.mergeable = True

class UndoableDelete(object):
    """something that has ben deleted from our textbuffer"""
    def __init__(self, text_buffer, start_iter, end_iter):
        self.text = text_buffer.get_text(start_iter, end_iter)
        self.start = start_iter.get_offset()
        self.end = end_iter.get_offset()
        # need to find out if backspace or delete key has been used
        # so we don't mess up during redo
        insert_iter = text_buffer.get_iter_at_mark(text_buffer.get_insert())
        if insert_iter.get_offset() <= self.start:
            self.delete_key_used = True
        else:
            self.delete_key_used = False
        if self.end - self.start > 1 or self.text in ("\r", "\n", " "):
            self.mergeable = False
        else:
            self.mergeable = True

class CodeBuffer(gtk.TextBuffer):
	def __init__(self):
		gtk.TextBuffer.__init__(self)
		
		self.tag = gtk.TextTag()
		self.tag.set_property("background", "lightblue")
		self.get_tag_table().add(self.tag)

		self.undo_stack = []
		self.redo_stack = []
		self.not_undoable_action = False
		self.undo_in_progress = False

		self.connect("notify::cursor-position", self.cursor_moved_event)
		self.connect('insert-text', self.on_insert_text)
		self.connect('delete-range', self.on_delete_range)

	def cursor_moved_event(self, sender, pos):
		self.remove_all_tags(self.get_start_iter(), self.get_end_iter())

		itr_start = self.get_iter_at_mark(self.get_insert())
		itr_end   = itr_start.copy()

		if itr_start.get_char() == '(':
			itr_end.forward_char()

			nesting = 1
			while nesting > 0:
				ch = itr_end.get_char()
				if ch == '(':
					nesting = nesting + 1
				elif ch == ')':
					nesting = nesting - 1
				if not itr_end.forward_char():
					break

			if nesting > 0:
				itr_end = itr_start.copy()
				itr_end.forward_char()

			itr_start.forward_char()
			self.apply_tag(self.tag, itr_start, itr_end)

		itr_end.backward_char()
		if itr_end.get_char() == ')':
			nesting = 1
			while itr_end.backward_char():
				ch = itr_end.get_char()
				if ch == '(':
					nesting = nesting - 1
				elif ch == ')':
					nesting = nesting + 1
				if nesting == 0:
					break
			else:
				itr_end = itr_start.copy()
				itr_end.backward_char()

			self.apply_tag(self.tag, itr_end, itr_start)

	@property
	def can_undo(self):
		return bool(self.undo_stack)

	@property
	def can_redo(self):
		return bool(self.redo_stack)

	def on_insert_text(self, textbuffer, text_iter, text, length):
		def can_be_merged(prev, cur):
			"""see if we can merge multiple inserts here

			will try to merge words or whitespace
			can't merge if prev and cur are not mergeable in the first place
			can't merge when user set the input bar somewhere else
			can't merge across word boundaries"""
			if not cur.mergeable or not prev.mergeable:
				return False
			elif cur.offset != (prev.offset + prev.length):
				return False
			elif cur.text in WHITESPACE and not prev.text in WHITESPACE:
				return False
			elif prev.text in WHITESPACE and not cur.text in WHITESPACE:
				return False
			return True

		if not self.undo_in_progress:
			self.redo_stack = []
		if self.not_undoable_action:
			return
		undo_action = UndoableInsert(text_iter, text, length)
		try:
			prev_insert = self.undo_stack.pop()
		except IndexError:
			self.undo_stack.append(undo_action)
			return
		if not isinstance(prev_insert, UndoableInsert):
			self.undo_stack.append(prev_insert)
			self.undo_stack.append(undo_action)
			return
		if can_be_merged(prev_insert, undo_action):
			prev_insert.length += undo_action.length
			prev_insert.text += undo_action.text
			self.undo_stack.append(prev_insert)
		else:
			self.undo_stack.append(prev_insert)
			self.undo_stack.append(undo_action)

	def on_delete_range(self, text_buffer, start_iter, end_iter):
		def can_be_merged(prev, cur):
			"""see if we can merge multiple deletions here

			will try to merge words or whitespace
			can't merge if prev and cur are not mergeable in the first place
			can't merge if delete and backspace key were both used
			can't merge across word boundaries"""

			WHITESPACE = (' ', '\t')
			if not cur.mergeable or not prev.mergeable:
				return False
			elif prev.delete_key_used != cur.delete_key_used:
				return False
			elif prev.start != cur.start and prev.start != cur.end:
				return False
			elif cur.text not in WHITESPACE and \
				prev.text in WHITESPACE:
				return False
			elif cur.text in WHITESPACE and \
				prev.text not in WHITESPACE:
				return False
			return True

		if not self.undo_in_progress:
			self.redo_stack = []
		if self.not_undoable_action:
			return
		undo_action = UndoableDelete(text_buffer, start_iter, end_iter)
		try:
			prev_delete = self.undo_stack.pop()
		except IndexError:
			self.undo_stack.append(undo_action)
			return
		if not isinstance(prev_delete, UndoableDelete):
			self.undo_stack.append(prev_delete)
			self.undo_stack.append(undo_action)
			return
		if can_be_merged(prev_delete, undo_action):
			if prev_delete.start == undo_action.start: # delete key used
				prev_delete.text += undo_action.text
				prev_delete.end += (undo_action.end - undo_action.start)
			else: # Backspace used
				prev_delete.text = "%s%s" % (undo_action.text,
                                                     prev_delete.text)
				prev_delete.start = undo_action.start
			self.undo_stack.append(prev_delete)
		else:
			self.undo_stack.append(prev_delete)
			self.undo_stack.append(undo_action)

	def begin_not_undoable_action(self):
		"""don't record the next actions

		toggles self.not_undoable_action"""
		self.not_undoable_action = True        

	def end_not_undoable_action(self):
		"""record next actions

		toggles self.not_undoable_action"""
		self.not_undoable_action = False

	def undo(self):
		"""undo inserts or deletions

		undone actions are being moved to redo stack"""
		if not self.undo_stack:
			return
		self.begin_not_undoable_action()
		self.undo_in_progress = True
		undo_action = self.undo_stack.pop()
		self.redo_stack.append(undo_action)
		if isinstance(undo_action, UndoableInsert):
			start = self.get_iter_at_offset(undo_action.offset)
			stop = self.get_iter_at_offset(
                undo_action.offset + undo_action.length
			)
			self.delete(start, stop)
			self.place_cursor(start)
		else:
			start = self.get_iter_at_offset(undo_action.start)
			self.insert(start, undo_action.text)
			stop = self.get_iter_at_offset(undo_action.end)
			if undo_action.delete_key_used:
				self.place_cursor(start)
			else:
				self.place_cursor(stop)
		self.end_not_undoable_action()
		self.undo_in_progress = False

	def redo(self):
		"""redo inserts or deletions

		redone actions are moved to undo stack"""
		if not self.redo_stack:
			return
		self.begin_not_undoable_action()
		self.undo_in_progress = True
		redo_action = self.redo_stack.pop()
		self.undo_stack.append(redo_action)
		if isinstance(redo_action, UndoableInsert):
			start = self.get_iter_at_offset(redo_action.offset)
			self.insert(start, redo_action.text)
			new_cursor_pos = self.get_iter_at_offset(
                redo_action.offset + redo_action.length
			)
			self.place_cursor(new_cursor_pos)
		else:
			start = self.get_iter_at_offset(redo_action.start)
			stop = self.get_iter_at_offset(redo_action.end)
			self.delete(start, stop)
			self.place_cursor(start)
		self.end_not_undoable_action()
		self.undo_in_progress = False


class Editor:
    modules = [
         ("English",   "WordNetEng.gf", "ParseEng.gf")
		,("Swedish",   "WordNetSwe.gf", "ParseSwe.gf")
        ,("Bulgarian", "WordNetBul.gf", "ParseBul.gf")
        ]

    def delete_event(self, widget, event, data=None):
        return False

    def destroy(self, widget, data=None):
        gtk.main_quit()

    def reset_editor(self):
        self.entry.set_text("");
        self.textbuffer_abstr.set_text("");
        self.textbuffer_abstr.set_modified(False)
        self.textbuffer_exmpl.set_text("");
        self.textbuffer_exmpl.set_modified(False)
        self.textbuffer_gloss.set_text("");
        self.textbuffer_gloss.set_modified(False)
        for (lang,wordnet,parse,textbuffer) in self.modules:
			textbuffer.set_text("")
			textbuffer.set_modified(False)
			
        self.webview.load_string("", "text/html", "UTF-8", "about:blank")

    def search_event(self, widget, data=None):
        self.notifyNeedsSave()

        query = self.entry.get_text()
        self.reset_editor()
        self.treestore.clear()

        if query in self.lemma2funs:
			del self.defs

			self.save_defs   = {}
			self.save_domain = None
			for fun in self.lemma2funs[query]:
				self.save_defs[fun] = {}
				values = [fun]
				for (lang, wordnet, parse, textbuffer) in self.modules:
					values.append("")
				it = self.treestore.append(None,values)
				for syn_fun in self.fun2synset.get(fun,[]):
					if fun == syn_fun:
						continue
					self.save_defs[syn_fun] = {}
					values = [syn_fun]
					for lang in self.modules:
						values.append("")
					self.treestore.append(it,values)

			self.defs = self.loadExamples(self.save_defs)
			self.loadAbstract()
			self.loadConcrete()

			self.updateDefsDomains()

			if self.gr_is_full:
			    self.updateLinearizations()
			else:
				self.buildMiniGrammar(True)
        else:
			self.save_defs   = None
			self.save_domain = None
			self.updateDomains(self.domains2funs)

        self.saveButton.set_sensitive(False)
        self.deleteButton.set_sensitive(False)

    def cursor_changed(self, treeview, data=None):
		(model, piter) = treeview.get_selection().get_selected()
		(path, column) = treeview.get_cursor()
		if piter == None:
			return

		self.notifyNeedsSave()

		i = 0
		for (lang,wordnet,parse,textbuffer) in self.modules:
			if lang == column.get_title():
				self.languageCombo.set_active(i)
			i = i + 1

		self.selectFunction(self.treestore.get_value(piter,0))

    def save_event(self, widget, data=None):
        self.saveAbstract()
        self.saveConcrete()

        if self.fun != self.new_fun:
			self.updateMapping()

			self.defs[self.new_fun] = self.defs[self.fun]
			del self.defs[self.fun]

			for lst in self.fun2lists[self.fun]:
				lst.remove(self.fun)
				lst.append(self.new_fun)
			self.fun2lists[self.new_fun] = self.fun2lists[self.fun]
			del self.fun2lists[self.fun]

			def update_tree_rows(treeiter):
				while treeiter is not None:
					if self.treestore[treeiter][0] == self.fun:
						self.treestore[treeiter][0] = self.new_fun

					if self.treestore.iter_has_child(treeiter):
						childiter = self.treestore.iter_children(treeiter)
						update_tree_rows(childiter)
					treeiter = self.treestore.iter_next(treeiter)

			update_tree_rows(self.treestore.get_iter_first())
			
			self.fun = self.new_fun
			del self.new_fun

        detected = self.detectNewFunctions()
        if detected:
			self.loadAbstract()
			self.loadConcrete()

        self.buildMiniGrammar(self.gr_is_full or detected)

        self.textbuffer_abstr.set_modified(False)
        self.textbuffer_gloss.set_modified(False)
        for (lang,wordnet,parse,textbuffer) in self.modules:
			textbuffer.set_modified(False)

        self.saveButton.set_sensitive(False)

    def delete_function_event(self, widget, data=None):
		self.deleteAbstract()
		self.deleteConcrete()
		self.deleteMapping()

		del self.defs[self.fun]
		for lst in self.fun2lists[self.fun]:
			lst.remove(self.fun)

		self.reset_editor()
		def remove_tree_rows(treeiter):
			while treeiter is not None:
				if self.treestore[treeiter][0] == self.fun:
					self.treestore.remove(treeiter)

				if self.treestore.iter_has_child(treeiter):
					childiter = self.treestore.iter_children(treeiter)
					remove_tree_rows(childiter)
				treeiter = self.treestore.iter_next(treeiter)

		remove_tree_rows(self.treestore.get_iter_first())
		
		self.deleteButton.set_sensitive(False)

    def browse_event(self, widget, data=None):
		if self.browseButton.get_active():
			self.editor.set_visible(False)
			self.browser.set_visible(True)
			self.languageComboItem.set_visible(True)
		else:
			self.editor.set_visible(True)
			self.browser.set_visible(False)
			self.languageComboItem.set_visible(False)

    def language_changed_event(self, widget, data=None):
		self.updateBrowser()

    def domain_toggled_event(self, cell, path, data=None):
		self.notifyNeedsSave()

		self.reset_editor()
		self.treestore.clear()

		self.liststore[path][0] = not self.liststore[path][0]

		start_domain = None
		start_defs   = {}
		all_selected = set()
		it = self.liststore.get_iter_first()
		while it != None:
			if self.liststore.get_value(it,0):
				start_domain = self.liststore.get_value(it,1)
				all_selected.add(start_domain)
			it = self.liststore.iter_next(it)

		if self.save_domain != None and not self.save_domain in all_selected:
			self.save_defs = None

		if start_domain != None:
			if self.save_defs == None:
				self.save_defs   = {}
				self.save_domain = start_domain
			
				for fun in self.domains2funs[start_domain]:
					self.save_defs[fun] = {}

				self.defs = self.loadExamples(self.save_defs)
				self.loadAbstract()
				self.loadConcrete()
		else:
			self.defs      = {}
			self.save_defs = None
			self.updateDomains(self.domains2funs)
			return

		domains = set()
		for fun in self.save_defs:
			if "WordNet.gf" in self.save_defs[fun] and all_selected.issubset(self.save_defs[fun]["WordNet.gf"][3]):
				for domain in self.save_defs[fun]["WordNet.gf"][3]:
					domains.add(domain)
				values = [fun]
				for (lang, wordnet, parse, textbuffer) in self.modules:
					values.append("")
				it = self.treestore.append(None,values)

		self.updateDomains(domains, all_selected)

		if self.gr_is_full:
			self.updateLinearizations()
		else:
			self.buildMiniGrammar(True)

		self.saveButton.set_sensitive(False)
		self.deleteButton.set_sensitive(False)

    def changed_event(self, widget, data=None):
		self.saveButton.set_sensitive(True)

    def needsSave(self):
		if (self.textbuffer_abstr.get_modified() or self.textbuffer_gloss.get_modified()):
			return True

		for (lang, wordnet, parse, textbuffer) in self.modules:
			if (textbuffer.get_modified()):
				return True

		return False

    def notifyNeedsSave(self):
		if self.needsSave():
			dlg = gtk.MessageDialog(self.window, type=gtk.MESSAGE_QUESTION, buttons=gtk.BUTTONS_YES_NO)
			dlg.set_markup("Do you want to save the changes?")

			response = dlg.run()
			dlg.destroy()

			if response == gtk.RESPONSE_YES:
				self.save_event(None, None)

    def setupTreeColumn(self, lang, i):
		tvcolumn = gtk.TreeViewColumn(lang)

		# add tvcolumns to treeview
		self.treeview.append_column(tvcolumn)

		cell = gtk.CellRendererText()

		# add the cell to the tvcolumn and allow it to expand
		tvcolumn.pack_start(cell, True)

		# set the cell "text" attribute to column 0 - retrieve text
		# from that column in treestore
		tvcolumn.add_attribute(cell, 'text', i)

		# Allow sorting on the column
		tvcolumn.set_sort_column_id(i)
		
		return tvcolumn

    def setupTextView(self,vbox,title):
		label = gtk.Label(title)
		label.set_alignment(0,0)

		textbuffer = gtk.TextBuffer()
		textbuffer.connect("changed", self.changed_event)

		textview = gtk.TextView()
		textview.set_buffer(textbuffer);
		
		viewport = gtk.Viewport()
		viewport.add(textview)

		vbox.pack_start(label,False)
		vbox.pack_start(viewport,False)
		
		return textbuffer
		
    def next_tree(self, widget, data=None):
		self.loadNextExample()

    def __init__(self):
		# load the grammar
        (self.lemma2funs,self.fun2lists) = self.buildFullGrammar()
        (self.fun2synset,self.domains2funs) = self.loadSynsetsAndDomains()

        self.defs        = {}
        self.save_defs   = None
        self.save_domain = None
        self.fun = None

        # create a new window
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.resize(1000,700)
    
        # When the window is given the "delete_event" signal (this is given
        # by the window manager, usually by the "close" option, or on the
        # titlebar), we ask it to call the delete_event () function
        # as defined above. The data passed to the callback
        # function is NULL and is ignored in the callback function.
        self.window.connect("delete_event", self.delete_event)
    
        # Here we connect the "destroy" event to a signal handler.  
        # This event occurs when we call gtk_widget_destroy() on the window,
        # or if we return FALSE in the "delete_event" callback.
        self.window.connect("destroy", self.destroy)
    
        # Sets the border width of the window.
        self.window.set_border_width(10)

        accel_group = gtk.AccelGroup()
        self.window.add_accel_group(accel_group)

        self.entry = gtk.Entry()
        self.entry.connect("activate", self.search_event, None)

        search_button = gtk.Button("Search")
        search_button.connect("clicked", self.search_event, None)

        hbox1 = gtk.HBox()
        hbox1.pack_start(self.entry,True)
        hbox1.pack_end(search_button,False)

        self.treestore = gtk.TreeStore(str,str,str,str)
        self.treeview = gtk.TreeView(self.treestore)
        self.treeview.connect('cursor-changed', self.cursor_changed, None)

        i = 0

        self.setupTreeColumn("Abstract", i)
        i = i+1

        for (lang,wordnet,parse) in self.modules:
			self.setupTreeColumn(lang, i)
			i = i+1

        scrolledwindow1 = gtk.ScrolledWindow()
        scrolledwindow1.add(self.treeview)

        self.liststore = gtk.ListStore(bool,str)
        self.listview  = gtk.TreeView(self.liststore)

        tvcolumn = gtk.TreeViewColumn("Domain")
        cell = gtk.CellRendererToggle()
        cell.set_property('activatable', True)
        cell.connect('toggled', self.domain_toggled_event)
        tvcolumn.pack_start(cell, False)
        tvcolumn.add_attribute(cell, 'active', 0)
        cell = gtk.CellRendererText()
        tvcolumn.pack_start(cell, True)
        tvcolumn.add_attribute(cell, 'text', 1)
        tvcolumn.set_sort_column_id(1)
        self.listview.append_column(tvcolumn)

        self.updateDomains(self.domains2funs)

        scrolledwindow2 = gtk.ScrolledWindow()
        scrolledwindow2.add(self.listview)

        vpaned = gtk.VPaned()
        vpaned.add1(scrolledwindow1)
        vpaned.add2(scrolledwindow2)
        vpaned.set_position(350)
        vpaned.show()
        
        toolbar = gtk.Toolbar()

        self.saveButton = gtk.ToolButton(gtk.STOCK_SAVE)
        self.saveButton.set_label("Save")
        self.saveButton.connect("clicked", self.save_event, None)
        toolbar.insert(self.saveButton, 0)

        self.deleteButton = gtk.ToolButton(gtk.STOCK_DELETE)
        self.deleteButton.set_label("Delete")
        self.deleteButton.connect("clicked", self.delete_function_event, None)
        toolbar.insert(self.deleteButton, 1)

        toolbar.insert(gtk.SeparatorToolItem(), 2)

        self.browseButton = gtk.ToggleToolButton(gtk.STOCK_FILE)
        self.browseButton.set_label("Browse")
        self.browseButton.connect("toggled", self.browse_event, None)
        toolbar.insert(self.browseButton, 3)
        
        toolbar.show_all()
        
        self.languageCombo = gtk.ComboBox(gtk.ListStore(str,str))
        cell = gtk.CellRendererText()
        self.languageCombo.pack_start(cell, True)
        self.languageCombo.add_attribute(cell, 'text', 0)
        for (lang,wordnet,parse) in self.modules:
			self.languageCombo.get_model().append([lang,parse])
        self.languageCombo.set_active(0)
        self.languageCombo.connect("changed", self.language_changed_event, None)
        self.languageCombo.show()
        self.languageComboItem = gtk.ToolItem()
        self.languageComboItem.add(self.languageCombo)
        toolbar.insert(self.languageComboItem, 4)

        self.saveButton.set_sensitive(False)
        self.saveButton.add_accelerator("clicked", accel_group,
                                        ord('S'), gtk.gdk.CONTROL_MASK, gtk.ACCEL_VISIBLE)

        self.deleteButton.set_sensitive(False)

        self.editor = gtk.VBox()

        self.textbuffer_gloss = self.setupTextView(self.editor, "Gloss")

        self.textbuffer_abstr = self.setupTextView(self.editor, "Abstract")

        for i in xrange(len(self.modules)):
			(lang,wordnet,parse) = self.modules[i]
			textbuffer = self.setupTextView(self.editor, lang)
			self.modules[i] = (lang,wordnet,parse,textbuffer)
        
        self.textbuffer_exmpl = CodeBuffer()
        self.textbuffer_exmpl.connect("changed", self.changed_event)

        textview_exmpl = gtk.TextView()
        textview_exmpl.set_buffer(self.textbuffer_exmpl);
        textview_exmpl.connect("key-press-event",self.textview_exmpl_key_press_event)

        textview_scrll = gtk.ScrolledWindow()
        textview_scrll.set_policy(gtk.POLICY_ALWAYS, gtk.POLICY_AUTOMATIC)
        textview_scrll.add(textview_exmpl)

        hbox = gtk.HBox()
        example_button = gtk.Button("Example")
        example_button.connect("clicked", self.next_tree, None)
        example_button.add_accelerator("activate", accel_group,
                                       ord('E'), gtk.gdk.CONTROL_MASK, gtk.ACCEL_VISIBLE)
        hbox.pack_start(example_button,False)

        self.editor.pack_start(hbox,False)
        self.editor.pack_start(textview_scrll,True)
        self.editor.show_all()

        self.browser = gtk.ScrolledWindow()
        self.webview = webkit.WebView()
        self.webview.show()
        self.browser.add(self.webview)

        vbox1 = gtk.VBox()
        vbox1.pack_start(hbox1, False)
        vbox1.pack_start(vpaned, True)
        vbox1.show_all()

        vbox2 = gtk.VBox()
        vbox2.pack_start(toolbar,False)
        vbox2.pack_start(self.editor,True)
        vbox2.pack_start(self.browser,True)
        vbox2.show()

        hpaned = gtk.HPaned()
        hpaned.add1(vbox1)
        hpaned.add2(vbox2)
        hpaned.set_position(350)
        hpaned.show()

        # This packs the button into the window (a GTK container).
        self.window.add(hpaned)

        # and the window
        self.window.show()

    def textview_exmpl_key_press_event(self,widget,event):
		if event.state & gtk.gdk.CONTROL_MASK:
			if event.keyval == 122:
				self.textbuffer_exmpl.undo()
			elif event.keyval == 121:
				self.textbuffer_exmpl.redo()

    def loadSynsetsAndDomains(self):
		f = open("WordNet.gf", "r")
		fun2synset   = {}
		domains2funs = {}
		synsets      = {}
		for line in f:
			ws = line.split()
			if len(ws) > 2 and ws[0] == "fun":
				fun = ws[1]
				parts = line.split('--')
				if len(parts) >= 2:
					abstr = parts[0].strip()
					[synset_id,descr] = "--".join(parts[1:]).split('\t')
					if synset_id in synsets:
						synset = synsets[synset_id]
					else:
						synset = []
						synsets[synset_id] = synset
					fun2synset[fun] = synset
					synset.append(fun)
					lists = self.fun2lists.setdefault(fun,[])
					lists.append(synset)

					descr = descr.strip()
					if len(descr) > 0 and descr[0] == '[':
						for domain in descr[1:].split(']')[0].split(','):
							domain = domain.strip()
							lst = domains2funs.setdefault(domain, [])
							lst.append(fun)
							lists = self.fun2lists.setdefault(fun,[])
							lists.append(lst)
		f.close()
		return (fun2synset,domains2funs)

    def loadAbstract(self):
		file_name = "WordNet.gf"
		f = open(file_name, "r")
		abstr  = None
		synset = None
		descr  = None
		for line in f:
			ws = line.split()
			if len(ws) > 2 and ws[0] == "fun" and ws[1] in self.defs:
				parts = line.split('--')
				if len(parts) >= 2:
					abstr = parts[0].strip()
					[synset,descr] = "--".join(parts[1:]).split('\t')
					synset = synset.strip()
					descr  = descr.strip()
					
					domains= []
					if len(descr) > 0 and descr[0] == '[':
						for domain in descr[1:].split(']')[0].split(','):
							domains.append(domain.strip())
				else:
					abstr    = line.strip()
					synset   = None
					descr    = ""
					domains  = []
				self.defs[ws[1]][file_name] = (abstr,synset,descr,domains)
		f.close()

    def saveAbstract(self):
		self.new_fun = self.fun

		if not (self.textbuffer_abstr.get_modified() or self.textbuffer_gloss.get_modified()):
			return

		abstr = self.textbuffer_abstr.get_text(*self.textbuffer_abstr.get_bounds())
		gloss = self.textbuffer_gloss.get_text(*self.textbuffer_gloss.get_bounds())

		ws = abstr.split()
		if len(ws) > 2 and ws[0] == "fun":
			self.new_fun = ws[1]

		file_name = "WordNet.gf"
		inp = open(file_name, "r")
		out = open("__temp__", "w")
		for line in inp:
			ws = line.split()
			if len(ws) > 2 and ws[0] == "fun" and ws[1] == self.fun:
				if self.synset == None:
					line = abstr
				else:
					line = abstr.ljust(35)+"-- "+self.synset+"\t"+gloss+"\n"
			out.write(line)
		inp.close()
		out.close()
		shutil.move("__temp__", "WordNet.gf")
		
		abs_def = self.defs[self.fun][file_name]
		self.defs[self.fun][file_name] = (abstr,abs_def[1],gloss,abs_def[3])

    def deleteAbstract(self):
		inp = open("WordNet.gf", "r")
		out = open("__temp__", "w")
		for line in inp:
			ws = line.split()
			if len(ws) > 2 and ws[0] == "fun" and ws[1] == self.fun:
				pass
			else:
				out.write(line)
		inp.close()
		out.close()
		shutil.move("__temp__", "WordNet.gf")

    def loadConcrete(self):
		for (lang,wordnet,parse,text_buffer) in self.modules:
			inp = open(wordnet, "r")
			while True:
				line = inp.readline()
				if line == '':
					break

				ws   = line.split()
				if len(ws) > 2 and ws[0] == "lin" and ws[1] in self.defs:
					count = 0
					body  = ""
					while line != '':
						body = body + line
						for c in line:
							if c == '{' or c == '(' or c == '[':
								count = count + 1
							if c == '}' or c == ')' or c == ']':
								count = count - 1
						if count == 0:
							break
						line = inp.readline()
					self.defs[ws[1]][wordnet] = body.strip()
			inp.close()

    def saveConcrete(self):
		for (lang,wordnet,parse,textbuffer) in self.modules:
			if not textbuffer.get_modified():
				continue

			concr = textbuffer.get_text(*textbuffer.get_bounds())

			inp = open(wordnet, "r")
			out = open("__temp__", "w")
			for line in inp:
				ws = line.split()
				if len(ws) > 2 and ws[0] == "lin" and ws[1] == self.fun:
					line = concr+"\n"
				out.write(line)
			inp.close()
			out.close()
			shutil.move("__temp__", wordnet)

			self.defs[self.fun][wordnet] = concr

    def deleteConcrete(self):
		for (lang,wordnet,parse,textbuffer) in self.modules:
			inp = open(wordnet, "r")
			out = open("__temp__", "w")
			for line in inp:
				ws = line.split()
				if len(ws) > 2 and ws[0] == "lin" and ws[1] == self.fun:
					pass
				else:
					out.write(line)
			inp.close()
			out.close()
			shutil.move("__temp__", wordnet)

    def updateMapping(self):
		inp = open("mapping.txt", "r")
		out = open("__temp__", "w")
		for line in inp:
			ws = line.split()
			if len(ws) > 1 and ws[1] == self.fun:
				line = ws[0] + "\t" + self.new_fun + "\n"
			out.write(line)
		inp.close()
		out.close()
		shutil.move("__temp__", "mapping.txt")

    def deleteMapping(self):
		inp = open("mapping.txt", "r")
		out = open("__temp__", "w")
		for line in inp:
			ws = line.split()
			if len(ws) > 1 and ws[1] == self.fun:
				pass
			else:
				out.write(line)
		inp.close()
		out.close()
		shutil.move("__temp__", "mapping.txt")

    def loadExampleLexicon(self,e,defs):
		app = e.unpack()
		if type(app) == tuple:
			fun = app[0]
			if fun in self.fun2synset:
				defs[fun] = {}
				values = [fun]
				for (lang,wordnet,parse,textbuffer) in self.modules:
					values.append("")
				it = self.treestore.append(None,values)

				for syn_fun in self.fun2synset.get(fun,[]):
					if fun == syn_fun:
						continue
					defs[syn_fun] = {}
					values = [syn_fun]
					for lang in self.modules:
						values.append("")
					self.treestore.append(it,values)
			else:
				for e in app[1]:
					self.loadExampleLexicon(e,defs)

    def loadExamples(self, defs):
		def addLexicon(e, new_defs):
			app = e.unpack()
			if type(app) == tuple:
				if len(app[1]) == 0 or app[0] in self.fun2synset:
					new_defs.setdefault(app[0], {})
				
				for e in app[1]:
					addLexicon(e, new_defs)

		new_defs = defs.copy()

		inp = open("examples.txt", "r")
		while True:
			l0 = inp.readline()
			l1 = inp.readline()
			l2 = inp.readline()
			l3 = inp.readline()
			l4 = inp.readline()
			l5 = inp.readline()

			if l0 == '':
				break

			ws = l4[5:-1].split()
			funs = ws[1:int(ws[0])+1]
			for fun in funs:
				if fun in defs:
					addLexicon(pgf.readExpr(l0[5:-1]), new_defs)

					lines = new_defs[fun].setdefault("examples.txt",[])
					lines.append(l0)
					lines.append(l1)
					lines.append(l2)
					lines.append(l3)
					lines.append(l4)
					lines.append(l5)
		inp.close()

		for fun in defs:
			examples = defs[fun].get("examples.txt",[])
			defs[fun]["examples.txt"] = "".join(examples)

		return new_defs

    def saveExamples(self, all_lines):
		inp = open("examples.txt", "r")
		out = open("__temp__", "w")

		l0 = inp.readline()
		while True:
			l1 = inp.readline()
			if l1 == '':
				break

			for xlines in all_lines:
				if xlines[1] == l1:
					l2 = inp.readline()
					l3 = inp.readline()
					l4 = inp.readline()
					l5 = inp.readline()

					for line in xlines:
						out.write(line)

					l0 = inp.readline()
					break
			else:
				out.write(l0)
				l0 = l1
		out.write(l0)

		out.close()
		inp.close()
		shutil.move("__temp__", "examples.txt")

    def updateExamples(self):
		lines     = []
		all_lines = []

		itr = self.textbuffer_exmpl.get_start_iter()
		while True:
			start = itr.copy()
			if not itr.forward_line():
				break
			line0 = self.textbuffer_exmpl.get_text(start,itr)
			if line0.startswith("abs*") or line0.startswith("abs:"):
				xlines = []

				xlines.append(line0)

				start = itr.copy(); itr.forward_line()
				line1 = self.textbuffer_exmpl.get_text(start,itr)
				xlines.append(line1)

				start = itr.copy(); itr.forward_line()
				line2 = self.textbuffer_exmpl.get_text(start,itr)
				xlines.append(line2)

				start = itr.copy(); itr.forward_line()
				line3 = self.textbuffer_exmpl.get_text(start,itr)
				xlines.append(line3)
					
				start = itr.copy(); itr.forward_line()
				line4 = self.textbuffer_exmpl.get_text(start,itr)
				xlines.append(line4)

				start = itr.copy(); itr.forward_line()
				line5 = self.textbuffer_exmpl.get_text(start,itr)
				xlines.append(line5)

				all_lines.append(xlines)

				lines.extend(xlines)
				l = len(lines)

				try:
					e = pgf.readExpr(line0[4:])
					(e,ty) = self.gr.inferExpr(e)

					lins = [lin.lower() for lin in self.gr.languages["ParseEng"].linearizeAll(e)]
					if not line1[5:-1].lower() in lins:
						lines.append("eng: "+lin+"\n")

					lins = [lin.lower() for lin in self.gr.languages["ParseSwe"].linearizeAll(e)]
					if not line2[5:-1].lower() in lins:
						lines.append("swe: "+lin+"\n")

					lins = [lin.lower() for lin in self.gr.languages["ParseBul"].linearizeAll(e)]
					if not line3[5:-1].lower() in lins:
						lines.append("bul: "+lin+"\n")
				except pgf.PGFError as e:
					lines.append(str(e))
				except pgf.TypeError as e:
					lines.append(str(e))

				if l != len(lines):
					lines.append("\n")

		if self.textbuffer_exmpl.get_modified():
			self.saveExamples(all_lines)

		examples = "".join(lines)
		self.defs[self.fun]["examples.txt"] = examples
		
		self.textbuffer_exmpl.set_text(examples)
		self.textbuffer_exmpl.set_modified(False)

    def loadNextExample(self):
		i     = -1
		lines = []
		inp = open("examples.txt", "r")
		for line in inp:
			if i < 0 and line.startswith("abs* Phr"):
				lines.append(line)
				i = 5
			elif i >= 0:
				lines.append(line)
				i = i - 1
				if i == 1:
					ws = line[5:-1].split()
					target_funs = ws[1:int(ws[0])+1]
				if i == 0:
					break
		inp.close()

		e = pgf.readExpr(lines[0][5:])
		self.treestore.clear()
		del self.defs

		self.save_defs = {}
		self.save_domain = None
		self.loadExampleLexicon(e,self.save_defs)
		self.defs = self.loadExamples(self.save_defs)
		for fun in target_funs:
			self.defs[fun]["examples.txt"] = "".join(lines)

		self.loadAbstract()
		self.loadConcrete()

		self.updateDefsDomains()
		self.selectFunction(target_funs[0])

		if not self.gr_is_full:
			buildMiniGrammar(True)

    def detectNewFunctions(self):
		def addLexicon(e):
			app = e.unpack()
			if type(app) == tuple:
				if len(app[1]) == 0:
					fun = app[0]
					if fun not in self.defs:
						self.defs[fun] = {}
						return True
				else:
					detected = False
					for e in app[1]:
						detected = detected or addLexicon(e)
					return detected
			else:
				return False

		detected = False
		itr = self.textbuffer_exmpl.get_start_iter()
		while True:
			start = itr.copy()
			if not itr.forward_line():
				break
			line = self.textbuffer_exmpl.get_text(start,itr)
			if line.startswith("abs*") or line.startswith("abs:"):
				try:
					e = pgf.readExpr(line[4:])
					detected = detected or addLexicon(e)
				except pgf.PGFError:
					pass
		return detected

    def updateBrowser(self):
		itr   = self.languageCombo.get_model().get_iter_from_string(str(self.languageCombo.get_active()))
		concr = self.gr.languages[self.languageCombo.get_model().get_value(itr,1)[:-3]]

		ty = self.gr.functionType(self.fun)
		if len(ty.hypos) == 0 and concr.hasLinearization("Inflection"+ty.cat):
			descr = self.textbuffer_gloss.get_text(*self.textbuffer_gloss.get_bounds())

			gloss    = ""
			i        = 0
			start    = i
			while i < len(descr):
				if descr[i] == ';':
					if descr[start] != '"':
						if gloss == "":
							gloss = descr[start:i]
						else:
							gloss = gloss + "; " + descr[start:i]
					i = i+1
					while i < len(descr) and descr[i].isspace():
						i = i+1
					start = i
				else:
					if descr[i] == '"':
						while i < len(descr) and descr[i] != '"':
							i = i+1
					i = i+1
			if not (start < len(descr) and descr[start] == '"'):
				if gloss == "":
					gloss = descr[start:i]
				else:
					gloss = gloss + "; " + descr[start:i]

			examples = "<ul>"
			itr = self.textbuffer_exmpl.get_start_iter()
			while True:
				start = itr.copy()
				if not itr.forward_line():
					break
				line0 = self.textbuffer_exmpl.get_text(start,itr)
				if line0.startswith("abs:"):
					e = pgf.readExpr(line0[4:])

					lin   = concr.linearize(e)
					examples = examples + "<li>" + lin + "</li>"
			examples = examples + "</ul>"

			e = pgf.Expr("MkDocument", [pgf.Expr("MkDefinition", [pgf.Expr(gloss),pgf.Expr(examples)]),
										pgf.Expr("Inflection"+ty.cat, [pgf.Expr(self.fun,[])]),
										pgf.Expr("")])

			doc = concr.linearize(e)
		else:
			doc = ""
		self.webview.load_string(doc, "text/html", "UTF-8", "wordnet://"+self.fun)

    def selectFunction(self,fun):
		self.fun = fun

		fun_defs = self.defs[self.fun]
		(abstr,self.synset,gloss,examples) = fun_defs["WordNet.gf"]

		self.textbuffer_abstr.set_text(abstr)
		self.textbuffer_abstr.set_modified(False)
		self.textbuffer_gloss.set_text(gloss)
		self.textbuffer_gloss.set_modified(False)

		self.textbuffer_exmpl.set_text(fun_defs["examples.txt"])
		self.textbuffer_exmpl.set_modified(False)

		for (lang, wordnet, parse, textbuffer) in self.modules:
			textbuffer.set_text(fun_defs[wordnet])
			textbuffer.set_modified(False)

		self.saveButton.set_sensitive(False)
		self.deleteButton.set_sensitive(True)
		
		self.updateBrowser()

    def buildFullGrammar(self):
		recompile = False
		if os.path.isfile("Parse.pgf"):
			source_files = []
			file_names = ["WordNet.gf", "Parse.gf"]
			for (lang,wordnet,parse) in self.modules:
				file_names.append(wordnet)
				file_names.append(parse)
			for file_name in file_names:
				if os.path.getmtime(file_name) >= os.path.getmtime("Parse.pgf"):
					recompile = True
					break
		else:
			recompile = True

		if recompile:
			cmd = ["gf", "--make"]
			for (lang,wordnet,parse) in self.modules:
				cmd.append(parse)
			subprocess.call(cmd)

		sys.stdout.write("Reading Parse.pgf... ")
		sys.stdout.flush()
		self.gr = pgf.readPGF("Parse.pgf")
		self.gr_is_full = True
		lemma2funs = {}
		fun2lists  = {}
		for lang in self.gr.languages:
			for (lemma,ans) in self.gr.languages[lang].fullFormLexicon():
				for (fun,an,prob) in ans:
					lst = lemma2funs.setdefault(lemma,[])
					if not fun in lst:
						lst.append(fun)
						lists = fun2lists.setdefault(fun,[])
						lists.append(lst)
		sys.stdout.write("\n")
		return (lemma2funs,fun2lists)

    def buildMiniGrammar(self, rebuild):
		modified = False
		if rebuild or self.textbuffer_abstr.get_modified():
			modified = True

			inp = open("Parse.gf", "r")
			out = open("lib/src/abstract/Parse.gf", "w")
			while True:
				l = inp.readline()
				if l == '':
					break
				if l == "  WordNet,\n":
					continue
				if l == "-- INJECT\n":
					for fun in self.defs:
						if "WordNet.gf" in self.defs[fun]:
							out.write(self.defs[fun]["WordNet.gf"][0]+"\n")
				else:
					out.write(l)
			out.close()
			inp.close()

		cmd = ["gf", "--make", "--output-dir=lib/src"]
		for (lang,wordnet,parse,textbuffer) in self.modules:
			file_name = "lib/src/"+lang.lower()+"/"+parse
			cmd.append(file_name)

			if rebuild or textbuffer.get_modified():
				modified = True

				inp = open(parse, "r")
				out = open(file_name, "w")
				skip = "  "+wordnet[:-3]+",\n"
				while True:
					l = inp.readline()
					if l == '':
						break
					if l == skip:
						continue
					if l == "-- INJECT\n":
						for fun in self.defs:
							if wordnet in self.defs[fun]:
								out.write(self.defs[fun][wordnet]+"\n")
					else:
						out.write(l)
				out.close()
				inp.close()

		def wait():
			if process.poll() != None:
				sys.stdout.write("Reading lib/src/Parse.pgf... ")
				sys.stdout.flush()
				self.gr = pgf.readPGF("lib/src/Parse.pgf")
				self.gr_is_full = False
				sys.stdout.write("\n")
				self.updateLinearizations()
				
				if self.fun != None:
					self.updateExamples()
					self.updateBrowser()
				return

			gtk.timeout_add(500, wait)

		if modified:
			process = subprocess.Popen(cmd)
			wait()
		else:
			if self.fun != None:
				self.updateExamples()

    def updateLinearizations(self):
		langs = self.gr.languages

		def update_tree_rows(treeiter):
			while treeiter is not None:
				i = 0

				fun = self.treestore[treeiter][0]
				e = pgf.Expr(fun, [pgf.Expr()]*len(self.gr.functionType(fun).hypos))
				i = i+1

				for (lang, wordnet, parse, textbuffer) in self.modules:
					self.treestore[treeiter][i] = langs[parse[:-3]].linearize(e)
					i = i+1

				if self.treestore.iter_has_child(treeiter):
					childiter = self.treestore.iter_children(treeiter)
					update_tree_rows(childiter)
				treeiter = self.treestore.iter_next(treeiter)

		update_tree_rows(self.treestore.get_iter_first())

    def updateDefsDomains(self):
		domains = set()
		for fun in self.save_defs:
			if "WordNet.gf" in self.save_defs[fun]:
				for domain in self.save_defs[fun]["WordNet.gf"][3]:
					domains.add(domain)
		self.updateDomains(domains, set())

    def updateDomains(self, domains, all_selected = set()):
		self.liststore.clear()
		for domain in domains:
			self.liststore.append([domain in all_selected,domain])

    def main(self):
		gtk.threads_enter()
		gtk.main()
		gtk.threads_leave()

# If the program is run directly or passed as an argument to the python
# interpreter then create a HelloWorld instance and show it
if __name__ == "__main__":
    editor = Editor()
    editor.main()
