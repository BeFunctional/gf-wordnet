#!/usr/bin/env python

import pygtk
pygtk.require('2.0')
import gtk
import pgf
import shutil
import subprocess
 
class Editor:

    # This is a callback function. The data arguments are ignored
    # in this example. More on callbacks below.
    def search(self, widget, data=None):
        query = self.entry.get_text();
        self.entry.set_text("");
        self.textbuffer_abstr.set_text("");
        self.textbuffer_gloss.set_text("");
        self.textbuffer_eng.set_text("");
        self.textbuffer_bul.set_text("");

        langs = self.gr.languages
        exprs = []
        for lang in langs:
            for (fun,an,prob) in langs[lang].lookupMorpho(query):
                exprs.append(pgf.Expr(fun,[]))
        self.treestore.clear()
        for e in exprs:
            values = [str(e)]
            for lang in langs:
			    values.append(langs[lang].linearize(e))
            self.treestore.append(values)

    def delete_event(self, widget, event, data=None):
        return False

    def destroy(self, widget, data=None):
        gtk.main_quit()
        
    def cursor_changed(self, treeview, data=None):
		(model, piter) = treeview.get_selection().get_selected()
		self.fun = self.treestore.get_value(piter,0)
		(abstr,self.synset,descr) = self.loadAbstract()
		concr                     = self.loadConcrete()
		self.textbuffer_abstr.set_text(abstr)
		self.textbuffer_gloss.set_text(descr)
		self.textbuffer_eng.set_text(concr[0])
		self.textbuffer_bul.set_text(concr[1])
		
    def save_event(self, widget, data=None):
        self.saveAbstract()
        self.saveConcrete()
        
    def execute_event(self, widget, data=None):
		subprocess.call(["gf", "--make", "WordNetEng.gf", "WordNetBul.gf"])
		# reload the grammar
        self.gr = pgf.readPGF("WordNet.pgf")

    def setupTextView(self,vbox,title):
		label = gtk.Label(title)
		label.set_alignment(0,0)

		textbuffer = gtk.TextBuffer()

		textview = gtk.TextView()
		textview.set_buffer(textbuffer);
		
		viewport = gtk.Viewport()
		viewport.add(textview)

		vbox.pack_start(label,False)
		vbox.pack_start(viewport,True)
		
		return textbuffer

    def __init__(self):
		# load the grammar
        self.gr = pgf.readPGF("WordNet.pgf")

        # create a new window
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.resize(1000,500)
    
        # When the window is given the "delete_event" signal (this is given
        # by the window manager, usually by the "close" option, or on the
        # titlebar), we ask it to call the delete_event () function
        # as defined above. The data passed to the callback
        # function is NULL and is ignored in the callback function.
        self.window.connect("delete_event", self.delete_event)
    
        # Here we connect the "destroy" event to a signal handler.  
        # This event occurs when we call gtk_widget_destroy() on the window,
        # or if we return FALSE in the "delete_event" callback.
        self.window.connect("destroy", self.destroy)
    
        # Sets the border width of the window.
        self.window.set_border_width(10)

        self.entry = gtk.Entry()
        self.entry.connect("activate", self.search, None)

        self.button = gtk.Button("Search")
        self.button.connect("clicked", self.search, None)
        
        hbox = gtk.HBox()
        hbox.pack_start(self.entry,True)
        hbox.pack_end(self.button,False)

        self.treestore = gtk.ListStore(str,str,str)
        self.treeview = gtk.TreeView(self.treestore)
        self.treeview.connect('cursor-changed', self.cursor_changed, None)

        # create the TreeViewColumns to display the data
        self.tvcolumn_abs = gtk.TreeViewColumn('Abstract')
        self.tvcolumn_eng = gtk.TreeViewColumn('English')
        self.tvcolumn_bul = gtk.TreeViewColumn('Bulgarian')

        # add tvcolumns to treeview
        self.treeview.append_column(self.tvcolumn_abs)
        self.treeview.append_column(self.tvcolumn_eng)
        self.treeview.append_column(self.tvcolumn_bul)

        self.cell_abs = gtk.CellRendererText()
        self.cell_eng = gtk.CellRendererText()
        self.cell_bul = gtk.CellRendererText()

        # add the cell to the tvcolumn and allow it to expand
        self.tvcolumn_abs.pack_start(self.cell_abs, True)
        self.tvcolumn_eng.pack_start(self.cell_eng, True)
        self.tvcolumn_bul.pack_start(self.cell_bul, True)

        # set the cell "text" attribute to column 0 - retrieve text
        # from that column in treestore
        self.tvcolumn_abs.add_attribute(self.cell_abs, 'text', 0)
        self.tvcolumn_eng.add_attribute(self.cell_eng, 'text', 1)
        self.tvcolumn_bul.add_attribute(self.cell_bul, 'text', 2)

        # make it searchable
        self.treeview.set_search_column(0)

        # Allow sorting on the column
        self.tvcolumn_abs.set_sort_column_id(0)
        self.tvcolumn_eng.set_sort_column_id(1)
        self.tvcolumn_bul.set_sort_column_id(2)

        # Allow drag and drop reordering of rows
        self.treeview.set_reorderable(True)

        scrolledwindow = gtk.ScrolledWindow()
        scrolledwindow.add(self.treeview)

        vbox1 = gtk.VBox()
        vbox1.pack_start(hbox,False)
        vbox1.pack_start(scrolledwindow,True)

        toolbar = gtk.Toolbar()
        toolbar.insert_stock(gtk.STOCK_SAVE,
                             "Saves the changes",
                             "Private",
                             self.save_event,
                             None, 0)
        toolbar.insert_stock(gtk.STOCK_EXECUTE,
                             "Executes the compiler",
                             "Private",
                             self.execute_event,
                             None, 1)
   
        vbox2 = gtk.VBox()
        vbox2.pack_start(toolbar,False)
        self.textbuffer_gloss = self.setupTextView(vbox2, "Gloss")
        self.textbuffer_exmpl = self.setupTextView(vbox2, "Examples")
        self.textbuffer_abstr = self.setupTextView(vbox2, "Abstract")
        self.textbuffer_eng   = self.setupTextView(vbox2, "English")
        self.textbuffer_bul   = self.setupTextView(vbox2, "Bulgarian")

        hpaned = gtk.HPaned()
        hpaned.add1(vbox1)
        hpaned.add2(vbox2)
        hpaned.set_position(300)

        # This packs the button into the window (a GTK container).
        self.window.add(hpaned)

        # and the window
        self.window.show_all()
        
    def loadAbstract(self):
		f = open("WordNet.gf", "r")
		abstr  = None
		synset = None
		descr  = None
		for line in f:
			ws = line.split()
			if len(ws) > 2 and ws[0] == "fun" and ws[1] == self.fun:
				[abstr,comment] = line.split('--')
				abstr = abstr.strip()
				[synset,descr] = comment.split('\t')
				synset = synset.strip()
				descr = descr.strip()
				break;
		f.close()
		return (abstr,synset,descr)

    def saveAbstract(self):
		inp = open("WordNet.gf", "r")
		out = open("__temp__", "w")
		for line in inp:
			ws = line.split()
			if len(ws) > 2 and ws[0] == "fun" and ws[1] == self.fun:
				line = self.textbuffer_abstr.get_text(*self.textbuffer_abstr.get_bounds()).ljust(35)+"-- "+self.synset+"\t"+self.textbuffer_gloss.get_text(*self.textbuffer_gloss.get_bounds())+"\n"
			out.write(line)
		inp.close()
		out.close()
		shutil.move("__temp__", "WordNet.gf")

    def loadConcrete(self):
		concr = []
		for file_name in ["WordNetEng.gf", "WordNetBul.gf"]:
			f = open(file_name, "r")
			for line in f:
				ws = line.split()
				if len(ws) > 2 and ws[0] == "lin" and ws[1] == self.fun:
					concr.append(line.strip())
					break;
			else:
				concr.append(None)
			f.close()
		return concr

    def saveConcrete(self):
		for (file_name, textbuffer) in [("WordNetEng.gf",self.textbuffer_eng), ("WordNetBul.gf",self.textbuffer_bul)]:
			inp = open(file_name, "r")
			out = open("__temp__", "w")
			for line in inp:
				ws = line.split()
				if len(ws) > 2 and ws[0] == "lin" and ws[1] == self.fun:
					line = textbuffer.get_text(*textbuffer.get_bounds())+"\n"
				out.write(line)
			inp.close()
			out.close()
			shutil.move("__temp__", file_name)

    def main(self):
        # All PyGTK applications must have a gtk.main(). Control ends here
        # and waits for an event to occur (like a key press or mouse event).
        gtk.main()

# If the program is run directly or passed as an argument to the python
# interpreter then create a HelloWorld instance and show it
if __name__ == "__main__":
    editor = Editor()
    editor.main()
