#!/usr/bin/env python

import pygtk
pygtk.require('2.0')
import gtk
import pgf
import shutil
import subprocess
 
class Editor:

    # This is a callback function. The data arguments are ignored
    # in this example. More on callbacks below.
    def search(self, widget, data=None):
        self.notifyNeedsSave()

        query = self.entry.get_text()
        self.entry.set_text("");
        self.textbuffer_abstr.set_text("");
        self.textbuffer_abstr.set_modified(False)
        self.textbuffer_gloss.set_text("");
        self.textbuffer_gloss.set_modified(False)
        for textbuffer in self.textbuffers:
			textbuffer.set_text("")
			textbuffer.set_modified(False)

        langs = self.gr.languages
        funs  = set()
        for lang in langs:
            for (fun,an,prob) in langs[lang].lookupMorpho(query):
                funs.add(fun)
        self.treestore.clear()
        for fun in funs:
            values = [fun]
            for lang in langs:
			    values.append(langs[lang].linearize(pgf.Expr(fun,[])))
            self.treestore.append(values)

        self.saveButton.set_sensitive(False)

    def delete_event(self, widget, event, data=None):
        return False

    def destroy(self, widget, data=None):
        gtk.main_quit()
        
    def cursor_changed(self, treeview, data=None):
		self.notifyNeedsSave()

		(model, piter) = treeview.get_selection().get_selected()
		self.fun = self.treestore.get_value(piter,0)
		(abstr,self.synset,descr) = self.loadAbstract()
		concr                     = self.loadConcrete()
		self.textbuffer_abstr.set_text(abstr)
		self.textbuffer_abstr.set_modified(False)
		self.textbuffer_gloss.set_text(descr)
		self.textbuffer_gloss.set_modified(False)
		for i in xrange(len(self.textbuffers)):
			self.textbuffers[i].set_text(concr[i])
			self.textbuffers[i].set_modified(False)

		self.saveButton.set_sensitive(False)

    def save_event(self, widget, data=None):
        self.saveAbstract()
        self.saveConcrete()

        self.saveButton.set_sensitive(False)

    def execute_event(self, widget, data=None):
		subprocess.Popen(["gf", "--make", "WordNetEng.gf", "WordNetSwe.gf", "WordNetBul.gf"])

    def reload_event(self, widget, data=None):
		# reload the grammar
		self.gr = pgf.readPGF("WordNet.pgf")

    def delete_function_event(self, widget, data=None):
		self.deleteAbstract()
		self.deleteConcrete()
		self.deleteMapping()

    def changed_event(self, widget, data=None):
		self.saveButton.set_sensitive(True)

    def needsSave(self):
		if (self.textbuffer_abstr.get_modified() or self.textbuffer_gloss.get_modified()):
			return True

		for textbuffer in self.textbuffers:
			if (textbuffer.get_modified()):
				return True

		return False

    def notifyNeedsSave(self):
		if self.needsSave():
			dlg = gtk.MessageDialog(self.window, type=gtk.MESSAGE_QUESTION, buttons=gtk.BUTTONS_YES_NO)
			dlg.set_markup("Do you want to save the changes?")

			response = dlg.run()
			dlg.destroy()

			if response == gtk.RESPONSE_YES:
				self.save_event(None, None)

    def setupTextView(self,vbox,title):
		label = gtk.Label(title)
		label.set_alignment(0,0)

		textbuffer = gtk.TextBuffer()
		textbuffer.connect("changed", self.changed_event)

		textview = gtk.TextView()
		textview.set_buffer(textbuffer);
		
		viewport = gtk.Viewport()
		viewport.add(textview)

		vbox.pack_start(label,False)
		vbox.pack_start(viewport,True)
		
		return textbuffer

    def __init__(self):
		# load the grammar
        self.gr = pgf.readPGF("WordNet.pgf")

        # create a new window
        self.window = gtk.Window(gtk.WINDOW_TOPLEVEL)
        self.window.resize(1000,500)
    
        # When the window is given the "delete_event" signal (this is given
        # by the window manager, usually by the "close" option, or on the
        # titlebar), we ask it to call the delete_event () function
        # as defined above. The data passed to the callback
        # function is NULL and is ignored in the callback function.
        self.window.connect("delete_event", self.delete_event)
    
        # Here we connect the "destroy" event to a signal handler.  
        # This event occurs when we call gtk_widget_destroy() on the window,
        # or if we return FALSE in the "delete_event" callback.
        self.window.connect("destroy", self.destroy)
    
        # Sets the border width of the window.
        self.window.set_border_width(10)

        self.entry = gtk.Entry()
        self.entry.connect("activate", self.search, None)

        self.button = gtk.Button("Search")
        self.button.connect("clicked", self.search, None)
        
        hbox = gtk.HBox()
        hbox.pack_start(self.entry,True)
        hbox.pack_end(self.button,False)

        self.treestore = gtk.ListStore(str,str,str,str)
        self.treeview = gtk.TreeView(self.treestore)
        self.treeview.connect('cursor-changed', self.cursor_changed, None)

        i = 0
        for lang_name in ['Abstract', 'English', 'Swedish', 'Bulgarian']:
			tvcolumn = gtk.TreeViewColumn(lang_name)

			# add tvcolumns to treeview
			self.treeview.append_column(tvcolumn)

			cell = gtk.CellRendererText()

			# add the cell to the tvcolumn and allow it to expand
			tvcolumn.pack_start(cell, True)

			# set the cell "text" attribute to column 0 - retrieve text
			# from that column in treestore
			tvcolumn.add_attribute(cell, 'text', i)

			# Allow sorting on the column
			tvcolumn.set_sort_column_id(i)

			i = i+1

        # make it searchable
        self.treeview.set_search_column(0)

        scrolledwindow = gtk.ScrolledWindow()
        scrolledwindow.add(self.treeview)

        vbox1 = gtk.VBox()
        vbox1.pack_start(hbox,False)
        vbox1.pack_start(scrolledwindow,True)

        accel_group = gtk.AccelGroup()
        self.window.add_accel_group(accel_group)

        toolbar = gtk.Toolbar()
        self.saveButton = toolbar.insert_stock(gtk.STOCK_SAVE,
                             "Saves the changes",
                             "Private",
                             self.save_event,
                             None, 0)
        toolbar.insert_stock(gtk.STOCK_EXECUTE,
                             "Executes the compiler",
                             "Private",
                             self.execute_event,
                             None, 1)
        toolbar.insert_stock(gtk.STOCK_REFRESH,
                             "Reloads the grammar",
                             "Private",
                             self.reload_event,
                             None, 2)
        toolbar.insert_stock(gtk.STOCK_DELETE,
                             "Deletes the current function",
                             "Private",
                             self.delete_function_event,
                             None, 3)

        self.saveButton.set_sensitive(False)
        self.saveButton.add_accelerator("activate", accel_group,
                                        ord('S'), gtk.gdk.CONTROL_MASK, gtk.ACCEL_VISIBLE)

        vbox2 = gtk.VBox()
        vbox2.pack_start(toolbar,False)
        self.textbuffer_gloss = self.setupTextView(vbox2, "Gloss")
        self.textbuffer_exmpl = self.setupTextView(vbox2, "Examples")
        self.textbuffer_abstr = self.setupTextView(vbox2, "Abstract")

        self.textbuffers = []
        self.textbuffers.append(self.setupTextView(vbox2, "English"))
        self.textbuffers.append(self.setupTextView(vbox2, "Swedish"))
        self.textbuffers.append(self.setupTextView(vbox2, "Bulgarian"))

        hpaned = gtk.HPaned()
        hpaned.add1(vbox1)
        hpaned.add2(vbox2)
        hpaned.set_position(350)

        # This packs the button into the window (a GTK container).
        self.window.add(hpaned)

        # and the window
        self.window.show_all()
        
    def loadAbstract(self):
		f = open("WordNet.gf", "r")
		abstr  = None
		synset = None
		descr  = None
		for line in f:
			ws = line.split()
			if len(ws) > 2 and ws[0] == "fun" and ws[1] == self.fun:
				[abstr,comment] = line.split('--')
				abstr = abstr.strip()
				[synset,descr] = comment.split('\t')
				synset = synset.strip()
				descr = descr.strip()
				break;
		f.close()
		return (abstr,synset,descr)

    def saveAbstract(self):
		if not (self.textbuffer_abstr.get_modified() or self.textbuffer_gloss.get_modified()):
			return

		inp = open("WordNet.gf", "r")
		out = open("__temp__", "w")
		for line in inp:
			ws = line.split()
			if len(ws) > 2 and ws[0] == "fun" and ws[1] == self.fun:
				line = self.textbuffer_abstr.get_text(*self.textbuffer_abstr.get_bounds()).ljust(35)+"-- "+self.synset+"\t"+self.textbuffer_gloss.get_text(*self.textbuffer_gloss.get_bounds())+"\n"
			out.write(line)
		inp.close()
		out.close()
		shutil.move("__temp__", "WordNet.gf")
		
		self.textbuffer_abstr.set_modified(False)
		self.textbuffer_gloss.set_modified(False)

    def deleteAbstract(self):
		inp = open("WordNet.gf", "r")
		out = open("__temp__", "w")
		for line in inp:
			ws = line.split()
			if len(ws) > 2 and ws[0] == "fun" and ws[1] == self.fun:
				pass
			else:
				out.write(line)
		inp.close()
		out.close()
		shutil.move("__temp__", "WordNet.gf")

    def loadConcrete(self):
		concr = []
		for file_name in ["WordNetEng.gf", "WordNetSwe.gf", "WordNetBul.gf"]:
			f = open(file_name, "r")
			for line in f:
				ws = line.split()
				if len(ws) > 2 and ws[0] == "lin" and ws[1] == self.fun:
					concr.append(line.strip())
					break;
			else:
				concr.append(None)
			f.close()
		return concr

    def saveConcrete(self):
		for (file_name, textbuffer) in [("WordNetEng.gf",self.textbuffers[0]), ("WordNetSwe.gf",self.textbuffers[1]), ("WordNetBul.gf",self.textbuffers[2])]:
			if not textbuffer.get_modified():
				continue

			inp = open(file_name, "r")
			out = open("__temp__", "w")
			for line in inp:
				ws = line.split()
				if len(ws) > 2 and ws[0] == "lin" and ws[1] == self.fun:
					line = textbuffer.get_text(*textbuffer.get_bounds())+"\n"
				out.write(line)
			inp.close()
			out.close()
			shutil.move("__temp__", file_name)

			textbuffer.set_modified(False)

    def deleteConcrete(self):
		for (file_name, textbuffer) in [("WordNetEng.gf",self.textbuffers[0]), ("WordNetSwe.gf",self.textbuffers[1]), ("WordNetBul.gf",self.textbuffers[2])]:
			inp = open(file_name, "r")
			out = open("__temp__", "w")
			for line in inp:
				ws = line.split()
				if len(ws) > 2 and ws[0] == "lin" and ws[1] == self.fun:
					pass
				else:
					out.write(line)
			inp.close()
			out.close()
			shutil.move("__temp__", file_name)

    def deleteMapping(self):
		inp = open("mapping.txt", "r")
		out = open("__temp__", "w")
		for line in inp:
			ws = line.split()
			if len(ws) > 1 and ws[1] == self.fun:
				pass
			else:
				out.write(line)
		inp.close()
		out.close()
		shutil.move("__temp__", "mapping.txt")

    def main(self):
        # All PyGTK applications must have a gtk.main(). Control ends here
        # and waits for an event to occur (like a key press or mouse event).
        gtk.main()

# If the program is run directly or passed as an argument to the python
# interpreter then create a HelloWorld instance and show it
if __name__ == "__main__":
    editor = Editor()
    editor.main()
